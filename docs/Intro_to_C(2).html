<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Introduction to C - Part 2</title>
    <meta name="description" content="Introduction to C -  Part 2/3">
    <link rel="shortcut icon" href="C.png" type="image/x-icon">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
        integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="./static/main.css" />
    <script
        src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?autorun=false&amp;lang=llvm"></script>
    <script>
        window.onload = (function () {
            let tags = document.getElementsByTagName("pre");
            let br = document.createElement("br");
            for (var i = 0; i < tags.length; ++i) {
                tags[i].classList.add("prettyprint");
            }
            tags = document.getElementsByTagName("code");
            console.log(tags);
            for (var i = 0; i < tags.length; ++i) {
                if (tags[i].classList.contains("language-c")) {
                    tags[i].classList.add("lang-c");
                    tags[i].classList.remove("language-c");
                }
            }
            PR.prettyPrint();
        })
    </script>



    <script>
        MathJax = {
            tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>

<body>

    <div class="head-foot">
        
        <a href="Intro_to_C(1).html" class="hf-elements">Prev</a>
        
        <a href="./" class="hf-elements">Home</a>
        
        <a href=" Intro_to_C(3).html" class="hf-elements">Next</a>
        
        <br>
    </div>
    <hr>
    <div class="container">
        <h1 id="introduction-to-c-part-2">Introduction to C - Part 2</h1>
<div class="toc">
<ul>
<li><a href="#introduction-to-c-part-2">Introduction to C - Part 2</a><ul>
<li><a href="#input">Input</a></li>
<li><a href="#operators">Operators</a><ul>
<li><a href="#types">Types</a><ul>
<li><a href="#1-arithmetic">1. Arithmetic</a></li>
<li><a href="#2-relational">2. Relational</a></li>
<li><a href="#3-logical">3. Logical</a></li>
<li><a href="#4-bitwise">4. Bitwise</a></li>
<li><a href="#5-assignment">5. Assignment</a></li>
<li><a href="#6-miscellaneous-operators">6. Miscellaneous Operators</a></li>
<li><a href="#dot-operator">Dot operator</a></li>
<li><a href="#comma-operator">Comma operator</a></li>
</ul>
</li>
<li><a href="#sizeof-operation">sizeof() operation</a></li>
</ul>
</li>
<li><a href="#operator-precedence">Operator Precedence</a></li>
<li><a href="#expressions">Expressions</a></li>
<li><a href="#escape-sequences">Escape Sequences</a><ul>
<li><a href="#type-casting-and-conversion">Type casting and conversion</a><ul>
<li><a href="#type-conversion-automatic">Type Conversion (Automatic)</a></li>
<li><a href="#type-casting">Type casting</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<h2 id="input">Input</h2>
<pre><code class="language-c">scanf(&quot;format specifier&quot;, &amp;identifier);
</code></pre>
<p>The format specifiers are as listed for <code>printf</code>. It is to be noted that for all format specifiers except <code>%c</code>, the input is taken till the next character &lt; space (in terms ASCII value), mostly <code>\n</code> or space (<code>' '</code>)</p>
<hr>
<h2 id="operators">Operators</h2>
<p>Used to perform arithmetic and logical operations.</p>
<h3 id="types">Types</h3>
<ol>
<li>Arithmetic</li>
<li>Relational</li>
<li>Logical</li>
<li>Bitwise</li>
<li>Assignment</li>
<li>Miscellaneous Operators</li>
</ol>
<h4 id="1-arithmetic">1. Arithmetic</h4>
<p>Perform arithmetic operations</p>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>+</code></td>
<td>Addition</td>
<td>2 <code>+</code> 3 <code>=</code> 5</td>
</tr>
<tr>
<td><code>-</code></td>
<td>Subtraction</td>
<td>2 <code>-</code> 3 <code>=</code> -1</td>
</tr>
<tr>
<td><code>*</code></td>
<td>Multiplication</td>
<td>2 <code>*</code> 3 <code>=</code> 6</td>
</tr>
<tr>
<td><code>/</code></td>
<td>Division (returns quotient)</td>
<td>2 <code>/</code> 3 <code>=</code> 0</td>
</tr>
<tr>
<td><code>%</code></td>
<td>Modulo (returns remainder)</td>
<td>2 <code>%</code> 3 <code>=</code> 2</td>
</tr>
<tr>
<td><code>++</code></td>
<td>Increment operator</td>
<td><code>++2</code> or <code>2++</code></td>
</tr>
<tr>
<td><code>--</code></td>
<td>Decrement operator</td>
<td><code>--3</code> or <code>3--</code></td>
</tr>
</tbody>
</table>
<h4 id="2-relational">2. Relational</h4>
<p>Relations between two variables</p>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>==</code></td>
<td>Equal</td>
<td>a <code>==</code> b</td>
</tr>
<tr>
<td><code>!=</code></td>
<td>Not Equal</td>
<td>a <code>!=</code> b</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>Greater</td>
<td>a <code>&gt;</code> b</td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>Greater or Equal</td>
<td>a <code>&gt;=</code> b</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>Lesser</td>
<td>a <code>&lt;</code> b</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>Lesser or Equal</td>
<td>a <code>&lt;=</code> b</td>
</tr>
</tbody>
</table>
<h4 id="3-logical">3. Logical</h4>
<p>Perform Logical operations</p>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&amp;&amp;</code></td>
<td>Logical Operator <code>AND</code></td>
</tr>
<tr>
<td>&#124;&#124;</td>
<td>Logical Operator <code>OR</code></td>
</tr>
<tr>
<td><code>!</code></td>
<td>Logical operator <code>NOT</code></td>
</tr>
</tbody>
</table>
<h4 id="4-bitwise">4. Bitwise</h4>
<p>Perform bitwise operations. This class of operators takes the binary form of each integer, and applies the operator of respective bits.</p>
<p>The binary forms are padded by <code>0</code> on the left to compensate the differences in number of bits to represent each value.</p>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Description</th>
<th>Syntax</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&amp;</code></td>
<td>Bitwise AND</td>
<td>x <code>&amp;</code> y</td>
<td>5 <code>&amp;</code> 2</td>
</tr>
<tr>
<td>&#124;</td>
<td>Bitwise OR</td>
<td>x &#124; y</td>
<td>5 &#124; 3</td>
</tr>
<tr>
<td><code>~</code></td>
<td>Bitwise NOT</td>
<td><code>~x</code></td>
<td><code>~1</code></td>
</tr>
<tr>
<td><code>^</code></td>
<td>Bitwise XOR</td>
<td>x <code>^</code> y</td>
<td>6 <code>^</code> 1</td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td>Shifts y bits in x to the left (Left shift operator)</td>
<td>x <code>&lt;&lt;</code> y</td>
<td>10 <code>&lt;&lt;</code> 2</td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>Shifts y bits in x to the right (Right Shift Operator)</td>
<td>x <code>&gt;&gt;</code> y</td>
<td>15 <code>&gt;&gt;</code> 2</td>
</tr>
</tbody>
</table>
<p><strong>1. Bitwise AND (<code>&amp;</code>):</strong></p>
<p>It applies Binary <code>AND</code> operation to every bit.</p>
<p>Eg:</p>
<pre><code class="language-c">5 &amp; 2 = 0

   5  = 101
   2  = 010 // Padding zeroes on left
5 &amp; 2 = 000 = 0
</code></pre>
<p><strong>2. Bitwise OR (<code>|</code>):</strong></p>
<p>It applies the Bitwise <code>OR</code> operation to every bit</p>
<p>Eg:</p>
<pre><code class="language-c">5 | 3 = 7

   5  = 101
   3  = 011 // Padding zeroes on left
5 | 3 = 111 = 7
</code></pre>
<p><strong>3. Bitwise NOT (<code>~</code>):</strong></p>
<p>It applies the negation/complement/ <code>NOT</code> operation. Additional to flipping the bits, it changes sign.</p>
<p>Eg:</p>
<pre><code class="language-c">~5 = 2

   5  = 101
   ~5 = 010 = 2
</code></pre>
<p><strong>Anomaly in <code>C</code>:</strong></p>
<p>The bitwise complement operator acts differently in <code>C</code>.</p>
<p>Instead of flipping the bits, it provides 2&rsquo;s complement of the number.</p>
<p>Two&rsquo;s complement is an operation on binary numbers. The 2&rsquo;s complement of a number is equal to the negative of the number plus 1, i.e.,</p>
<pre><code class="language-txt">~N = -(N + 1)
</code></pre>
<p>So,</p>
<pre><code class="language-c">~5 = -(5 + 1) = -6
</code></pre>
<p><strong>4. Bitwise XOR (<code>^</code>):</strong></p>
<p>It applies the <code>Exclusive OR</code> (<code>XOR</code>) operation for each bit.</p>
<p>Eg:</p>
<pre><code class="language-c">6 ^ 2 = 4

   6  = 110
   2  = 010 // Padding zeroes on left
6 ^ 1 = 100 = 4
</code></pre>
<p><strong>5. Left Shift Operator (<code>&lt;&lt;</code>):</strong></p>
<p>Shifts the bits to the left by adding trailing zeros and removing start bits (MSB) which overflows.</p>
<p>Eg:</p>
<pre><code class="language-c">5 &lt;&lt; 2 = 20
5  = 101
5 &lt;&lt; 2 = 10100 = 20

</code></pre>
<p><strong>6. Right Shift Operator (<code>&gt;&gt;</code>):</strong></p>
<p>Shifts the bits to the right by adding leading zeroes and removing End bits (LSB).</p>
<p>Eg:</p>
<pre><code class="language-c">15 &gt;&gt; 2 = 0
15  = 1111
15 &gt;&gt; 2 = 0011 = 3
</code></pre>
<h4 id="5-assignment">5. Assignment</h4>
<p>Assigns value to a variable</p>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>=</code></td>
<td>Assign</td>
<td>c <code>=</code> 30</td>
</tr>
<tr>
<td><code>+=</code></td>
<td>Add and assign</td>
<td>a <code>+=</code> b</td>
</tr>
<tr>
<td><code>-=</code></td>
<td>Subtract and assign</td>
<td>a <code>-=</code> b</td>
</tr>
<tr>
<td><code>*=</code></td>
<td>Multiply and assign</td>
<td>a <code>*=</code> b</td>
</tr>
<tr>
<td><code>/=</code></td>
<td>Divide and assign</td>
<td>a <code>/=</code> b</td>
</tr>
<tr>
<td><code>%=</code></td>
<td>Get remainder and assign</td>
<td>a <code>%=</code> b</td>
</tr>
<tr>
<td><code>&lt;&lt;=</code></td>
<td>Left Shift and assign</td>
<td>a <code>&lt;&lt;=</code> b</td>
</tr>
<tr>
<td><code>&gt;&gt;=</code></td>
<td>Right Shift and assign</td>
<td>a <code>&gt;&gt;=</code> b</td>
</tr>
<tr>
<td><code>&amp;=</code></td>
<td>Bitwise AND and assign</td>
<td>a <code>&amp;=</code> b</td>
</tr>
<tr>
<td>&#124;=</td>
<td>Bitwise OR and assign</td>
<td>a | = b</td>
</tr>
<tr>
<td><code>^=</code></td>
<td>Bitwise XOR and assign</td>
<td>a <code>^=</code> b</td>
</tr>
</tbody>
</table>
<h4 id="6-miscellaneous-operators">6. Miscellaneous Operators</h4>
<p>Besides the operators discussed above, there are a few other important operators supported by C language</p>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&amp;</code></td>
<td>Address Operator (returns Address of a identifier)</td>
<td><code>&amp;a</code></td>
</tr>
<tr>
<td><code>*</code></td>
<td>Pointer to a variable / Dereferencing operator</td>
<td><code>*a</code></td>
</tr>
<tr>
<td><code>?</code></td>
<td>Ternary Operator</td>
<td><code>condition? a: b</code></td>
</tr>
<tr>
<td><code>.</code></td>
<td>dot operator</td>
<td><code>var1.var2</code></td>
</tr>
<tr>
<td><code>-&gt;</code></td>
<td>Arrow or Member access operator</td>
<td><code>(pointer)-&gt;(member)</code></td>
</tr>
<tr>
<td><code>,</code></td>
<td>Comma operator</td>
<td><code>a, b</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>Check pointers topic for more details on dereferencing operator and address operator</p>
</blockquote>
<h4 id="dot-operator">Dot operator</h4>
<p>The dot ( <code>.</code> ) operator is used for direct member selection via object name. In other words, it is used to access the child object/variable.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="language-c">&lt;variable_name&gt;.&lt;member_name&gt;
</code></pre>
<blockquote>
<p>The dot and arrow operator will be addressed in structures and unions.</p>
</blockquote>
<h4 id="comma-operator">Comma operator</h4>
<p>The comma token (<code>,</code>) acts as both a separator and an operator.</p>
<p>The comma operator is used to evaluate multiple expressions in the same statement.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="language-c">(expression1, expression2, expression3, ...)
</code></pre>
<p>When used inside a parenthesis, the expressions separated by comma are evaluated sequentially, the result being the result of last expression.</p>
<p>Eg:</p>
<pre><code class="language-c">#include&lt;stdio.h&gt;

int main() {
   int x = 10, y = 20;
   int a = (x--, y + 2);

   printf(&quot;x = %d, y = %d, a = %d&quot;, x, y, a);
}
</code></pre>
<p>Output:</p>
<pre><code class="language-txt">x = 9, y = 20, a = 22
</code></pre>
<h3 id="sizeof-operation"><code>sizeof()</code> operation</h3>
<p>The <code>sizeof</code> function is a builtin function available in <code>stdio.h</code> header file. It returns an integer indicating the size of memory in bytes, allocated to the specific variable.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="language-c">sizeof(&lt;variable_name&gt;);
// or
sizeof(&lt;type&gt;);
</code></pre>
<hr>
<h2 id="operator-precedence">Operator Precedence</h2>
<p>Operator precedence determines the grouping of terms in an expression and decides how an expression is evaluated. Certain operators have higher precedence than others; for example, the multiplication operator has a higher precedence than the addition operator.</p>
<table>
<thead>
<tr>
<th>Category</th>
<th>Operator</th>
<th>Associativity</th>
</tr>
</thead>
<tbody>
<tr>
<td>Postfix</td>
<td><code>()</code> <code>[]</code> <code>−&gt;</code> <code>.</code> <code>++</code> <code>−−</code></td>
<td>Left to right</td>
</tr>
<tr>
<td>Unary</td>
<td><code>+</code> <code>−</code> <code>!</code> <code>~</code> <code>++</code> <code>−−</code> <code>(type)</code> <code>*</code> <code>&amp;</code> <code>sizeof</code></td>
<td>Right to left</td>
</tr>
<tr>
<td>Multiplicative</td>
<td><code>*</code> <code>/</code> <code>%</code></td>
<td>Left to right</td>
</tr>
<tr>
<td>Additive</td>
<td><code>+</code> <code>−</code></td>
<td>Left to right</td>
</tr>
<tr>
<td>Shift</td>
<td><code>&lt;&lt;</code> <code>&gt;&gt;</code></td>
<td>Left to right</td>
</tr>
<tr>
<td>Relational</td>
<td><code>&lt;</code> <code>&lt;=</code> <code>&gt;</code> <code>&gt;=</code></td>
<td>Left to right</td>
</tr>
<tr>
<td>Equality</td>
<td><code>==</code> <code>!=</code></td>
<td>Left to right</td>
</tr>
<tr>
<td>Bitwise AND</td>
<td><code>&amp;</code></td>
<td>Left to right</td>
</tr>
<tr>
<td>Bitwise XOR</td>
<td><code>^</code></td>
<td>Left to right</td>
</tr>
<tr>
<td>Bitwise OR</td>
<td>&#124;</td>
<td>Left to right</td>
</tr>
<tr>
<td>Logical AND</td>
<td><code>&amp;&amp;</code></td>
<td>Left to right</td>
</tr>
<tr>
<td>Logical OR</td>
<td>&#124;&#124;</td>
<td>Left to right</td>
</tr>
<tr>
<td>Conditional (Ternary)</td>
<td><code>?:</code></td>
<td>Right to left</td>
</tr>
<tr>
<td>Assignment</td>
<td><code>=</code> <code>+=</code> <code>−=</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>&gt;&gt;=</code> <code>&lt;&lt;=</code> <code>&amp;=</code> <code>^=</code> &#124;=</td>
<td>Right to left</td>
</tr>
<tr>
<td>Comma</td>
<td><code>,</code></td>
<td>Left to right</td>
</tr>
</tbody>
</table>
<blockquote>
<p><code>(type)</code> means type casting operation</p>
</blockquote>
<hr>
<h2 id="expressions">Expressions</h2>
<p>A statement that gives a finite value.</p>
<p>Types:</p>
<ol>
<li>Infix expressions:<br>
   Example: 12 + 23</li>
<li>Prefix expressions:<br>
   Example: + 12 23</li>
<li>Postfix expressions:<br>
   Example: 12 23 +</li>
</ol>
<hr>
<h2 id="escape-sequences">Escape Sequences</h2>
<p>Few special characters defined under ASCII for formatting strings/output. The <code>\</code> is used to escape the original use of a character.</p>
<table>
<thead>
<tr>
<th>Sequence</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td>\ \</td>
<td>Back slash</td>
</tr>
<tr>
<td>\&lsquo;</td>
<td>Apostrophe or Single quotes</td>
</tr>
<tr>
<td>\n</td>
<td>new line or line feed</td>
</tr>
<tr>
<td>\f</td>
<td>form feed</td>
</tr>
<tr>
<td>\r</td>
<td>carriage return</td>
</tr>
<tr>
<td>\t</td>
<td>horizontal tab</td>
</tr>
<tr>
<td>\&ldquo;</td>
<td>Double quotes</td>
</tr>
<tr>
<td>\0</td>
<td>Null character</td>
</tr>
<tr>
<td>\a</td>
<td>bell</td>
</tr>
<tr>
<td>\v</td>
<td>vertical tab</td>
</tr>
</tbody>
</table>
<h3 id="type-casting-and-conversion">Type casting and conversion</h3>
<p>Converting one datatype into another is known as <strong>type casting</strong> or, <strong>type-conversion</strong>. For example, if you want to store a &lsquo;long&rsquo; value into a simple integer then you can type cast <code>long</code> to <code>int</code>.</p>
<p>It happens in two ways:</p>
<ol>
<li>Automatic type conversion</li>
<li>Forced type conversion / type casting</li>
</ol>
<h4 id="type-conversion-automatic">Type Conversion (Automatic)</h4>
<p>At points, we use some operation that needs values in different type than defined. The compiler, by default, converts the data type automatically to support the expression.</p>
<ol>
<li>char $\rightarrow$ int</li>
<li>int $\rightarrow$ char</li>
<li>int $\rightarrow$ float</li>
<li>int $\rightarrow$ double</li>
</ol>
<p>This is done by the <code>Arithmetic converter</code>. The following is the basic hierarchy of conversion.</p>
<p>$$\text{long double}$$
$$\uparrow$$
$$\text{double} $$
$$\uparrow$$
$$\text{float}$$
$$\uparrow$$
$$\text{unsigned long long}$$
$$\uparrow$$
$$\text{long long}$$
$$\uparrow$$
$$\text{unsigned long}$$
$$\uparrow$$
$$\text{long}$$
$$\uparrow$$
$$\text{unsigned int}$$
$$\uparrow$$
$$\text{int}$$</p>
<p>Eg:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {

   int  i = 17;
   char c = 'c'; /* ascii value is 99 */
   float sum;

   sum = i + c;
   printf(&quot;Value of sum : %f\n&quot;, sum );
   return 0;
}
</code></pre>
<p>output</p>
<pre><code class="language-c">Value of sum : 116.000000
</code></pre>
<p>Here, it is simple to understand that first c gets converted to integer, but as the final value is <code>float</code>, usual arithmetic conversion applies and the compiler converts <code>i</code> and <code>c</code> into <code>float</code> and adds them yielding a <code>float</code> result.</p>
<h4 id="type-casting">Type casting</h4>
<p>To have custom type conversion that are not supported by default, we do type casting.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="language-c">(type_name) expression
</code></pre>
<p>Eg:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {

   int sum = 17, count = 5;
   double mean;

   mean = (double) sum / count;
   printf(&quot;Value of mean : %f\n&quot;, mean );
   return 0;
}
</code></pre>
<p>Output</p>
<pre><code class="language-txt">Value of mean : 3.400000
</code></pre>
<hr>
    </div>

    <div class="head-foot">
        
        <a href="Intro_to_C(1).html" class="hf-elements">Prev</a>
        
        <a href="./" class="hf-elements">Home</a>
        
        <a href=" Intro_to_C(3).html" class="hf-elements">Next</a>
        
        <br>
    </div>
    <hr>

</body>

</html>